{
  "version": 3,
  "sources": ["../../../src/client/classes/WorkerPool.ts", "../../../src/client/functions/async/obtain.ts", "../../../src/client/test/workerPoolObtain.test.ts"],
  "sourcesContent": ["export class WorkerPool {\n    constructor(\n      private maxWorkers: number,\n      private workers: { worker: Worker, idle: boolean }[] = [],\n      private taskQueue: Array<() => void> = []\n    ) {\n      for (let i = 0; i < this.maxWorkers; i++) {\n        // Dynamically create a worker from a Blob with worker code\n        const workerCode = `\n          self.onmessage = async (event) => {\n            const { result, delay } = event.data;\n            // Simulate async task with delay\n            await new Promise(resolve => setTimeout(resolve, delay || 100));\n            self.postMessage({ result });\n          };\n        `;\n        const blob = new Blob([workerCode], { type: \"application/javascript\" });\n        const worker = new Worker(URL.createObjectURL(blob), { type: \"module\" });\n  \n        worker.onmessage = this.handleWorkerMessage.bind(this, i);\n        this.workers.push({ worker, idle: true });\n      }\n    }\n  \n    private handleWorkerMessage(workerIndex: number, event: MessageEvent) {\n      const { result } = event.data;\n      console.log(result);\n      this.workers[workerIndex].idle = true;\n      this.assignTask();\n    }\n  \n    submitTask<T>(taskData: { result: T; delay?: number }): Promise<T> {\n      return new Promise((resolve, reject) => {\n        const assignToWorker = () => {\n          for (const workerWrapper of this.workers) {\n            if (workerWrapper.idle) {\n              workerWrapper.idle = false;\n  \n              // Ensure we are sending only serializable data (resolved result)\n              workerWrapper.worker.postMessage({ result: taskData.result, delay: taskData.delay });\n  \n              workerWrapper.worker.onmessage = (event: MessageEvent) => {\n                resolve(event.data.result);\n                workerWrapper.idle = true;\n                this.assignTask();\n              };\n  \n              workerWrapper.worker.onerror = (error) => {\n                reject(error);\n                workerWrapper.idle = true;\n                this.assignTask();\n              };\n  \n              return;\n            }\n          }\n  \n          // If no workers are idle, queue the task\n          this.taskQueue.push(() => this.submitTask(taskData).then(resolve).catch(reject));\n        };\n  \n        assignToWorker();\n      });\n    }\n  \n    private assignTask() {\n      if (this.taskQueue.length > 0) {\n        const task = this.taskQueue.shift();\n        if (task) task();\n      }\n    }\n  }", "import { WorkerPool } from \"../../classes/WorkerPool.ts\";\n\ntype ObtainOptions = {\n  cache?: boolean; // Use cached data if available\n  paginate?: boolean; // Handle pagination if required\n  maxCacheAge?: number; // Time in milliseconds before cache is invalidated\n  retries?: number; // Number of retries if an operation fails\n  parallel?: boolean; // Run the operation in parallel using a worker pool\n  maxWorkers?: number; // Maximum number of workers for parallel processing\n  batch?: boolean; // Batch async operations if needed\n};\n\nexport function obtain<T>(\n  asyncOperation: () => Promise<T>, // Each async operation returns a promise\n  options: ObtainOptions = {}\n): Promise<T[]> {\n  const {\n    cache = true,\n    paginate = false,\n    maxCacheAge = 60000,\n    retries = 3,\n    parallel = false,\n    maxWorkers = 4,\n    batch = false,\n  } = options;\n\n  let cacheData: { result: Promise<T[]>; timestamp: number } | null = null;\n\n  return new Promise((resolve, reject) => {\n    try {\n      if (cache && cacheData) {\n        const cacheAge = Date.now() - cacheData.timestamp;\n        if (cacheAge < maxCacheAge) {\n          resolve(cacheData.result);\n          return;\n        }\n      }\n\n      let result: Promise<T[]>;\n\n      if (parallel) {\n        const workerPool = new WorkerPool(maxWorkers);\n        result = new Promise((resolve, reject) => {\n          if (batch) {\n            const taskPromises = [asyncOperation, asyncOperation].map(async (task) => {\n              const resolvedResult = await task();\n              return workerPool.submitTask({ result: resolvedResult, delay: 100 });\n            });\n\n            Promise.all(taskPromises)\n              .then((resolvedTasks) => resolve(resolvedTasks as T[]))\n              .catch(reject);\n          } else {\n            asyncOperation().then(resolvedResult => {\n              workerPool.submitTask({ result: resolvedResult, delay: 100 })\n                .then((result) => resolve([result])) // Unwrap the resolved result\n                .catch(reject);\n            });\n          }\n        });\n      } else {\n        // Non-parallel execution with retry logic\n        result = batch\n          ? Promise.all([retryOperation(asyncOperation, retries)]).then((res) => res as T[])\n          : retryOperation(asyncOperation, retries).then((result) => [result]);\n      }\n\n      if (cache) {\n        cacheData = { result, timestamp: Date.now() };\n      }\n\n      if (paginate) {\n        // Handle pagination logic here if needed\n      }\n\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nasync function retryOperation<T>(\n  operation: () => Promise<T>,\n  retries: number\n): Promise<T> {\n  let lastError;\n  for (let attempt = 0; attempt < retries; attempt++) {\n    try {\n      // Attempt the operation\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      console.warn(`Attempt ${attempt + 1} failed. Retrying...`);\n\n      // If all retries are exhausted, throw the last encountered error\n      if (attempt === retries - 1) {\n        throw lastError;\n      }\n    }\n  }\n  throw lastError; // In case the loop completes without a successful operation\n}\n", "import { WorkerPool } from \"../classes/WorkerPool.ts\";\nimport { obtain } from \"../functions/async/obtain.ts\";\n\n// Mock async operation that succeeds after a delay\nfunction mockAsyncSuccess<T>(result: T, delay: number): Promise<T> {\n  return new Promise((resolve) => setTimeout(() => resolve(result), delay));\n}\n\n// Mock async operation that fails after a delay\nfunction mockAsyncFailure(delay: number): Promise<void> {\n  return new Promise((_, reject) =>\n    setTimeout(() => reject(new Error(\"Failed operation\")), delay)\n  );\n}\n\nDeno.test(\"WorkerPool processes tasks in parallel\", async () => {\n    const workerPool = new WorkerPool(2); // Two workers\n  \n    // Resolve promises before sending them to the worker\n    const task1 = workerPool.submitTask({ result: await Promise.resolve(\"task1\"), delay: 100 });\n    const task2 = workerPool.submitTask({ result: await Promise.resolve(\"task2\"), delay: 50 });\n  \n    const [result1, result2] = await Promise.all([task1, task2]);\n  \n    // Verify that tasks completed successfully\n    if (result1 !== \"task1\" || result2 !== \"task2\") {\n      throw new Error(`Expected \"task1\" and \"task2\" but got ${result1} and ${result2}`);\n    }\n  });\n\n  Deno.test(\"WorkerPool queues tasks when workers are busy\", async () => {\n    const workerPool = new WorkerPool(1); // Only one worker, so task2 should queue\n  \n    // Resolve promises before sending them to the worker\n    const task1 = workerPool.submitTask({ result: await Promise.resolve(\"task1\"), delay: 100 });\n    const task2 = workerPool.submitTask({ result: await Promise.resolve(\"task2\"), delay: 50 }); // This should queue\n  \n    const result1 = await task1;\n    const result2 = await task2;\n  \n    // Ensure tasks completed successfully in order\n    if (result1 !== \"task1\" || result2 !== \"task2\") {\n      throw new Error(\n        `Expected \"task1\" and \"task2\" but got ${result1} and ${result2}`\n      );\n    }\n  });\n\nDeno.test(\n  \"obtain function batches tasks when batch option is true\",\n  async () => {\n    const tasks = [\n      () => mockAsyncSuccess(\"task1\", 100),\n      () => mockAsyncSuccess(\"task2\", 50),\n    ];\n\n    // Call obtain and batch the tasks properly\n    const result = await obtain(\n      () => Promise.all(tasks.map((task) => task())),\n      { batch: true, parallel: true }\n    );\n\n    // Ensure correct results by accessing the nested array\n    if (\n      result[0].length !== 2 ||\n      result[0][0] !== \"task1\" ||\n      result[0][1] !== \"task2\"\n    ) {\n      throw new Error(`Expected [\"task1\", \"task2\"] but got ${result}`);\n    }\n  }\n);\n\nDeno.test(\"obtain function retries on failure\", async () => {\n  let attempts = 0;\n  const failingOperation = () => {\n    attempts++;\n    return mockAsyncFailure(50);\n  };\n\n  try {\n    await obtain(failingOperation, { retries: 3 });\n    throw new Error(\"Expected failure but operation succeeded\");\n  } catch (error) {\n    // Ensure it failed after 3 attempts\n    if (attempts !== 3) {\n      throw new Error(`Expected 3 attempts but got ${attempts}`);\n    }\n  }\n});\n\nDeno.test(\"obtain function uses cache if available\", async () => {\n  const mockOperation = () => mockAsyncSuccess(\"cachedData\", 50);\n\n  const result1 = await obtain(mockOperation, { cache: true });\n  const result2 = await obtain(mockOperation, { cache: true });\n\n  // Ensure both results are the same due to caching\n  if (result1[0] !== \"cachedData\" || result2[0] !== \"cachedData\") {\n    throw new Error(\n      `Expected cached data but got ${result1[0]} and ${result2[0]}`\n    );\n  }\n});\n\nDeno.test(\"obtain function handles errors correctly\", async () => {\n  const failingOperation = () => mockAsyncFailure(50);\n\n  try {\n    await obtain(failingOperation);\n    throw new Error(\"Expected failure but operation succeeded\");\n  } catch (error) {\n    if ((error as Error).message !== \"Failed operation\") {\n      throw new Error(\n        `Expected \"Failed operation\" but got \"${(error as Error).message}\"`\n      );\n    }\n  }\n});\n"],
  "mappings": "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",
  "names": ["resolve", "reject", "result"]
}
