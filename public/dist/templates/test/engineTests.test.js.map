{
  "version": 3,
  "sources": ["../../../../src/client/reactivity/reactive.ts", "../../../../src/client/templates/engine.ts", "../../../../src/client/components/core/SkyeComponent.ts", "../../../../src/client/templates/utils/hashTemplate.ts", "../../../../src/client/templates/utils/lazyRender.ts", "../../../../src/client/templates/test/engineTests.test.ts"],
  "sourcesContent": ["let activeEffect: Effect | null = null;\nconst effectStack: Effect[] = [];\n\nclass Dep {\n  subscribers: Set<Effect> = new Set();\n\n  depend() {\n    if (activeEffect) {\n      this.subscribers.add(activeEffect);\n      activeEffect.deps.add(this);\n    }\n  }\n\n  notify() {\n    const effects = Array.from(this.subscribers); // Collect subscribers\n\n    for (const effect of effects) {\n      if (effect.suspended) {\n        effect.resume();\n      } else {\n        effect.run();\n      }\n    }\n  }\n}\n\ntype EffectFnType = () => void | Promise<void>;\n\nclass Effect {\n  key: string;\n  fn: EffectFnType;\n  deps: Set<Dep> = new Set();\n  active: boolean = true;\n  suspended: boolean = false;\n  allowMutate: boolean = true;\n  running: boolean = false; // Add this line\n\n  constructor(fn: EffectFnType, key?: string) {\n    this.key = key || \"default\";\n    this.fn = fn;\n  }\n\n  run() {\n    if (!this.active || this.running) return; // Prevent re-entrant execution\n\n    this.running = true; // Set running to true\n\n    cleanupEffect(this);\n\n    try {\n      effectStack.push(this);\n      activeEffect = this;\n      this.allowMutate = false;\n\n      const result = this.fn();\n\n      if (result instanceof Promise) {\n        this.suspend();\n        result.finally(() => {\n          this.resume();\n        });\n      }\n    } finally {\n      this.allowMutate = true;\n      this.running = false; // Set running to false\n      effectStack.pop();\n      activeEffect = effectStack[effectStack.length - 1] || null;\n    }\n  }\n\n  suspend() {\n    this.suspended = true;\n  }\n\n  resume() {\n    if (this.suspended) {\n      this.suspended = false;\n    }\n  }\n\n  stop() {\n    if (this.active) {\n      cleanupEffect(this);\n      this.active = false;\n    }\n  }\n}\n\nfunction cleanupEffect(effect: Effect) {\n  effect.deps.forEach((dep) => {\n    dep.subscribers.delete(effect);\n  });\n  effect.deps.clear();\n}\nexport function effect(\n  fnOrEffects:\n    | (() => void | Promise<void>)\n    | { [key: string]: () => void | Promise<void> }\n): () => void {\n  let effectInstances: Effect[] = [];\n\n  if (typeof fnOrEffects === \"function\") {\n    // Single function\n    const effectInstance = new Effect(fnOrEffects, \"default\");\n    effectInstance.run();\n    effectInstances = [effectInstance];\n  } else {\n    // Object of functions\n    effectInstances = Object.entries(fnOrEffects).map(([key, fn]) => {\n      const effectInstance = new Effect(fn, key);\n      effectInstance.run();\n      return effectInstance;\n    });\n  }\n\n  return () => {\n    effectInstances.forEach((effectInstance) => effectInstance.stop());\n  };\n}\n\nexport function reactive<T extends object>(target: T): T {\n  const depMap = new Map<PropertyKey, Dep>();\n\n  const proxy = new Proxy(target, {\n    get(obj, prop: PropertyKey, receiver) {\n      let dep = depMap.get(prop);\n      if (!dep) {\n        dep = new Dep();\n        depMap.set(prop, dep);\n      }\n      dep.depend();\n      return Reflect.get(obj, prop, receiver);\n    },\n    set(obj, prop: PropertyKey, value, receiver) {\n      if (activeEffect && !activeEffect.allowMutate) {\n        throw new Error(\n          `Cannot mutate reactive state during effect execution.`\n        );\n      }\n\n      const oldValue = Reflect.get(obj, prop, receiver);\n      const result = Reflect.set(obj, prop, value, receiver);\n\n      if (oldValue !== value) {\n        const dep = depMap.get(prop);\n        if (dep) {\n          dep.notify();\n        }\n      }\n      return result;\n    },\n    // Other traps if needed\n  });\n\n  return proxy;\n}\n", "import { effect } from \"../reactivity/reactive.ts\";\n\nexport function parseTemplate(template: string, state: Record<string, any> = {}): DocumentFragment {\n  const fragment = document.createDocumentFragment();\n  const bindings: Array<{ node: Text; expression: string }> = [];\n\n  let index = 0;\n  const length = template.length;\n\n  while (index < length) {\n    const openIndex = template.indexOf('{{', index);\n\n    if (openIndex === -1) {\n      // Append remaining text\n      const text = template.slice(index);\n      fragment.appendChild(document.createTextNode(text));\n      break;\n    }\n\n    // Append text before the expression\n    if (openIndex > index) {\n      const text = template.slice(index, openIndex);\n      fragment.appendChild(document.createTextNode(text));\n    }\n\n    // Find the closing '}}'\n    const closeIndex = template.indexOf('}}', openIndex + 2);\n    if (closeIndex === -1) {\n      // No closing '}}', append the rest as text\n      const text = template.slice(openIndex);\n      fragment.appendChild(document.createTextNode(text));\n      break;\n    }\n\n    // Extract and evaluate the expression\n    const expression = template.slice(openIndex + 2, closeIndex).trim();\n    const textNode = document.createTextNode('');\n    fragment.appendChild(textNode);\n\n    // Evaluate and set initial value\n    updateTextNode(textNode, expression, state);\n\n    // Keep track of bindings for reactivity\n    bindings.push({ node: textNode, expression });\n\n    // Move the index past the closing '}}'\n    index = closeIndex + 2;\n  }\n\n  // Set up reactivity for each binding\n  bindings.forEach(({ node, expression }) => {\n    effect({\n      update() {\n        updateTextNode(node, expression, state);\n      },\n    });\n  });\n\n  return fragment;\n}\n\nfunction updateTextNode(node: Text, expression: string, state: Record<string, any>) {\n  try {\n    const value = new Function(...Object.keys(state), `return ${expression};`)(...Object.values(state));\n    node.textContent = value;\n  } catch (error) {\n    console.error(`Error evaluating expression \"${expression}\":`, error);\n    node.textContent = '';\n  }\n}\n\nexport function html(strings: string[], ...expressions: any[]) {\n  // Combine strings and expressions\n  let result = '';\n  for (let i = 0; i < strings.length; i++) {\n    result += strings[i];\n    if (i < expressions.length) {\n      const expr = expressions[i];\n      // If the expression is a function, execute it\n      if (typeof expr === 'function') {\n        result += expr();\n      } else {\n        result += expr;\n      }\n    }\n  }\n  return result;\n}\n\nexport function parseTemplateString(templateString: string) {\n  // Create a template element\n  const template = document.createElement('template');\n  template.innerHTML = templateString.trim();\n\n  // Return the content of the template as a DocumentFragment\n  return template.content.cloneNode(true);\n}", "import { effect, reactive } from \"../../reactivity/reactive.ts\";\nimport { parseTemplateString } from \"../../templates/engine.ts\";\n\nexport class SkyeComponent extends HTMLElement {\n  state: any;\n  private cleanupTasks: Array<() => void> = [];\n\n  constructor() {\n    super();\n    this.state = reactive({});\n  }\n\n  connectedCallback(): void {\n    // Set up the reactive effect and get the cleanup function\n    const cleanupRenderEffect = effect(() => this.render());\n\n    // Automatically clean up the effect on disconnect\n    this.addCleanupTask(cleanupRenderEffect);\n  }\n\n  disconnectedCallback(): void {\n    // Execute all cleanup tasks\n    this.cleanupTasks.forEach((cleanup) => cleanup());\n    this.cleanupTasks = [];\n  }\n\n  render(): void {\n    const template = this.template();\n    const fragment = parseTemplateString(template);\n    this.innerHTML = '';\n    this.appendChild(fragment);\n  }\n\n  template(): string {\n    // To be overridden by subclasses\n    return '';\n  }\n\n  // Helper method to add a cleanup task\n  protected addCleanupTask(task: () => void): void {\n    this.cleanupTasks.push(task);\n  }\n\n  // Helper method to add event listeners with automatic cleanup\n  protected addEventListenerWithCleanup<K extends keyof HTMLElementEventMap>(\n    type: K,\n    listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    this.addEventListener(type, listener, options);\n    this.addCleanupTask(() => this.removeEventListener(type, listener, options));\n  }\n}\n\nexport type Constructor<T = {}> = new (...args: any[]) => T;", "export async function hashTemplate(template: string): Promise<string> {\n  const response = await fetch(\"http://localhost:8000/api/hash\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ template }),\n  });\n\n  const res = await response.json();\n\n  if (response.ok) {\n    return res.data;\n  } else {\n    throw new Error(`Hashing failed: ${res.error}`);\n  }\n}", "import { effect } from \"../../reactivity/reactive.ts\";\nimport { parseTemplate } from \"../engine.ts\";\nimport { hashTemplate } from \"./hashTemplate.ts\";\n\nconst templateCache = new Map<string, { hash: string, fragment: DocumentFragment }>();\n\nexport async function renderTemplate(\n  template: string, \n  state: Record<string, any>, \n  element: HTMLElement\n) {\n  try {\n    // Generate hash for the template\n    const templateHash = await hashTemplate(template);\n\n    // Check if the template is cached and matches the current hash\n    const cachedTemplate = templateCache.get(template);\n    let fragment: DocumentFragment;\n    if (cachedTemplate && cachedTemplate.hash === templateHash) {\n      fragment = cachedTemplate.fragment.cloneNode(true) as DocumentFragment;\n    } else {\n      // Parse the template and bind it with the state\n      fragment = parseTemplate(template, state);\n\n      // Cache the new template with its hash\n      templateCache.set(template, { hash: templateHash, fragment });\n    }\n\n    // Clear the element's content and append the fragment\n    element.innerHTML = '';\n    element.appendChild(fragment);\n\n    // Set up reactivity effect\n    effect({\n      update: () => {\n        // Re-parse the template based on the updated state\n        const updatedFragment = parseTemplate(template, state);\n        element.innerHTML = ''; \n        element.appendChild(updatedFragment);\n      }\n    });\n\n  } catch (error) {\n    console.error(\"Error in renderTemplate:\", error);\n    throw error;\n  }\n}", "import { SkyeComponent } from \"../../components/core/SkyeComponent.ts\";\nimport { renderTemplate } from \"../utils/lazyRender.ts\";\n\nDeno.test(\"Template caching and hashing\", async () => {\n    const template = `<h1>{{ title }}</h1>`;\n    const state = { title: \"Skye Framework\" };\n    const element = document.createElement(\"div\");\n  \n    // Initial render\n    await renderTemplate(template, state, element);\n    const initialHTML = element.innerHTML;\n  \n    // Update the state but without changing the template\n    state.title = \"Updated Title\";\n    await renderTemplate(template, state, element);\n  \n    // Ensure the DOM was updated correctly\n    if (element.innerHTML !== \"<h1>Updated Title</h1>\") {\n      throw new Error(`Expected <h1>Updated Title</h1> but got ${element.innerHTML}`);\n    }\n  \n    // Change state back to the original, verify it's cached\n    state.title = \"Skye Framework\";\n    await renderTemplate(template, state, element);\n  \n    if (element.innerHTML === initialHTML) {\n      throw new Error(\"Template was incorrectly re-rendered from cache.\");\n    }\n  });\n\n  Deno.test(\"Fine-grained reactivity\", async () => {\n    const template = `<h1>{{ title }}</h1><p>{{ description }}</p>`;\n    const state = { title: \"Skye Framework\", description: \"A modern JS framework\" };\n    const element = document.createElement(\"div\");\n  \n    // Initial render\n    await renderTemplate(template, state, element);\n  \n    // Update only the description\n    state.description = \"Updated description\";\n    await renderTemplate(template, state, element);\n  \n    // Ensure the title was not re-rendered\n    if (element.querySelector(\"h1\")?.textContent !== \"Skye Framework\") {\n      throw new Error(\"Title should not have been re-rendered.\");\n    }\n  \n    // Ensure the description was updated\n    if (element.querySelector(\"p\")?.textContent !== \"Updated description\") {\n      throw new Error(\"Description was not updated correctly.\");\n    }\n  });\n\n  Deno.test(\"DocumentFragment integration and caching\", async () => {\n    const component = new SkyeComponent();\n    const fragment = component.autoParseTemplate();\n  \n    if (!(fragment instanceof DocumentFragment)) {\n      throw new Error(\"autoParseTemplate did not return a DocumentFragment\");\n    }\n  \n    // Append to the DOM\n    const element = document.createElement(\"div\");\n    element.appendChild(fragment.cloneNode(true));\n  \n    // Ensure the fragment's content is correct\n    const h1 = element.querySelector(\"h1\");\n    if (!h1 || h1.textContent !== \"{{ title }}\") {\n      throw new Error(\"DocumentFragment did not hydrate correctly.\");\n    }\n  \n    // Test caching by rendering again\n    await renderTemplate(\"<h1>{{ title }}</h1>\", { title: \"New Title\" }, element);\n    const cachedHTML = element.innerHTML;\n  \n    await renderTemplate(\"<h1>{{ title }}</h1>\", { title: \"Cached Title\" }, element);\n    if (element.innerHTML === cachedHTML) {\n      throw new Error(\"DocumentFragment was not rehydrated from cache.\");\n    }\n  });"],
  "mappings": "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",
  "names": ["effect"]
}
