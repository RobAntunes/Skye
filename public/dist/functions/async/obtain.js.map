{
  "version": 3,
  "sources": ["../../../../src/client/classes/WorkerPool.ts", "../../../../src/client/functions/async/obtain.ts"],
  "sourcesContent": ["export class WorkerPool {\n    constructor(\n      private maxWorkers: number,\n      private workers: { worker: Worker, idle: boolean }[] = [],\n      private taskQueue: Array<() => void> = []\n    ) {\n      for (let i = 0; i < this.maxWorkers; i++) {\n        // Dynamically create a worker from a Blob with worker code\n        const workerCode = `\n          self.onmessage = async (event) => {\n            const { result, delay } = event.data;\n            // Simulate async task with delay\n            await new Promise(resolve => setTimeout(resolve, delay || 100));\n            self.postMessage({ result });\n          };\n        `;\n        const blob = new Blob([workerCode], { type: \"application/javascript\" });\n        const worker = new Worker(URL.createObjectURL(blob), { type: \"module\" });\n  \n        worker.onmessage = this.handleWorkerMessage.bind(this, i);\n        this.workers.push({ worker, idle: true });\n      }\n    }\n  \n    private handleWorkerMessage(workerIndex: number, event: MessageEvent) {\n      const { result } = event.data;\n      console.log(result);\n      this.workers[workerIndex].idle = true;\n      this.assignTask();\n    }\n  \n    submitTask<T>(taskData: { result: T; delay?: number }): Promise<T> {\n      return new Promise((resolve, reject) => {\n        const assignToWorker = () => {\n          for (const workerWrapper of this.workers) {\n            if (workerWrapper.idle) {\n              workerWrapper.idle = false;\n  \n              // Ensure we are sending only serializable data (resolved result)\n              workerWrapper.worker.postMessage({ result: taskData.result, delay: taskData.delay });\n  \n              workerWrapper.worker.onmessage = (event: MessageEvent) => {\n                resolve(event.data.result);\n                workerWrapper.idle = true;\n                this.assignTask();\n              };\n  \n              workerWrapper.worker.onerror = (error) => {\n                reject(error);\n                workerWrapper.idle = true;\n                this.assignTask();\n              };\n  \n              return;\n            }\n          }\n  \n          // If no workers are idle, queue the task\n          this.taskQueue.push(() => this.submitTask(taskData).then(resolve).catch(reject));\n        };\n  \n        assignToWorker();\n      });\n    }\n  \n    private assignTask() {\n      if (this.taskQueue.length > 0) {\n        const task = this.taskQueue.shift();\n        if (task) task();\n      }\n    }\n  }", "import { WorkerPool } from \"../../classes/WorkerPool.ts\";\n\ntype ObtainOptions = {\n  cache?: boolean; // Use cached data if available\n  paginate?: boolean; // Handle pagination if required\n  maxCacheAge?: number; // Time in milliseconds before cache is invalidated\n  retries?: number; // Number of retries if an operation fails\n  parallel?: boolean; // Run the operation in parallel using a worker pool\n  maxWorkers?: number; // Maximum number of workers for parallel processing\n  batch?: boolean; // Batch async operations if needed\n};\n\nexport function obtain<T>(\n  asyncOperation: () => Promise<T>, // Each async operation returns a promise\n  options: ObtainOptions = {}\n): Promise<T[]> {\n  const {\n    cache = true,\n    paginate = false,\n    maxCacheAge = 60000,\n    retries = 3,\n    parallel = false,\n    maxWorkers = 4,\n    batch = false,\n  } = options;\n\n  let cacheData: { result: Promise<T[]>; timestamp: number } | null = null;\n\n  return new Promise((resolve, reject) => {\n    try {\n      if (cache && cacheData) {\n        const cacheAge = Date.now() - cacheData.timestamp;\n        if (cacheAge < maxCacheAge) {\n          resolve(cacheData.result);\n          return;\n        }\n      }\n\n      let result: Promise<T[]>;\n\n      if (parallel) {\n        const workerPool = new WorkerPool(maxWorkers);\n        result = new Promise((resolve, reject) => {\n          if (batch) {\n            const taskPromises = [asyncOperation, asyncOperation].map(async (task) => {\n              const resolvedResult = await task();\n              return workerPool.submitTask({ result: resolvedResult, delay: 100 });\n            });\n\n            Promise.all(taskPromises)\n              .then((resolvedTasks) => resolve(resolvedTasks as T[]))\n              .catch(reject);\n          } else {\n            asyncOperation().then(resolvedResult => {\n              workerPool.submitTask({ result: resolvedResult, delay: 100 })\n                .then((result) => resolve([result])) // Unwrap the resolved result\n                .catch(reject);\n            });\n          }\n        });\n      } else {\n        // Non-parallel execution with retry logic\n        result = batch\n          ? Promise.all([retryOperation(asyncOperation, retries)]).then((res) => res as T[])\n          : retryOperation(asyncOperation, retries).then((result) => [result]);\n      }\n\n      if (cache) {\n        cacheData = { result, timestamp: Date.now() };\n      }\n\n      if (paginate) {\n        // Handle pagination logic here if needed\n      }\n\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nasync function retryOperation<T>(\n  operation: () => Promise<T>,\n  retries: number\n): Promise<T> {\n  let lastError;\n  for (let attempt = 0; attempt < retries; attempt++) {\n    try {\n      // Attempt the operation\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      console.warn(`Attempt ${attempt + 1} failed. Retrying...`);\n\n      // If all retries are exhausted, throw the last encountered error\n      if (attempt === retries - 1) {\n        throw lastError;\n      }\n    }\n  }\n  throw lastError; // In case the loop completes without a successful operation\n}\n"],
  "mappings": "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",
  "names": ["resolve", "reject", "result"]
}
