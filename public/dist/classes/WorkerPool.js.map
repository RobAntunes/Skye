{
  "version": 3,
  "sources": ["../../../src/client/classes/WorkerPool.ts"],
  "sourcesContent": ["export class WorkerPool {\n    constructor(\n      private maxWorkers: number,\n      private workers: { worker: Worker, idle: boolean }[] = [],\n      private taskQueue: Array<() => void> = []\n    ) {\n      for (let i = 0; i < this.maxWorkers; i++) {\n        // Dynamically create a worker from a Blob with worker code\n        const workerCode = `\n          self.onmessage = async (event) => {\n            const { result, delay } = event.data;\n            // Simulate async task with delay\n            await new Promise(resolve => setTimeout(resolve, delay || 100));\n            self.postMessage({ result });\n          };\n        `;\n        const blob = new Blob([workerCode], { type: \"application/javascript\" });\n        const worker = new Worker(URL.createObjectURL(blob), { type: \"module\" });\n  \n        worker.onmessage = this.handleWorkerMessage.bind(this, i);\n        this.workers.push({ worker, idle: true });\n      }\n    }\n  \n    private handleWorkerMessage(workerIndex: number, event: MessageEvent) {\n      const { result } = event.data;\n      console.log(result);\n      this.workers[workerIndex].idle = true;\n      this.assignTask();\n    }\n  \n    submitTask<T>(taskData: { result: T; delay?: number }): Promise<T> {\n      return new Promise((resolve, reject) => {\n        const assignToWorker = () => {\n          for (const workerWrapper of this.workers) {\n            if (workerWrapper.idle) {\n              workerWrapper.idle = false;\n  \n              // Ensure we are sending only serializable data (resolved result)\n              workerWrapper.worker.postMessage({ result: taskData.result, delay: taskData.delay });\n  \n              workerWrapper.worker.onmessage = (event: MessageEvent) => {\n                resolve(event.data.result);\n                workerWrapper.idle = true;\n                this.assignTask();\n              };\n  \n              workerWrapper.worker.onerror = (error) => {\n                reject(error);\n                workerWrapper.idle = true;\n                this.assignTask();\n              };\n  \n              return;\n            }\n          }\n  \n          // If no workers are idle, queue the task\n          this.taskQueue.push(() => this.submitTask(taskData).then(resolve).catch(reject));\n        };\n  \n        assignToWorker();\n      });\n    }\n  \n    private assignTask() {\n      if (this.taskQueue.length > 0) {\n        const task = this.taskQueue.shift();\n        if (task) task();\n      }\n    }\n  }"],
  "mappings": ";AAAO,IAAM,aAAN,MAAiB;AAAA,EACpB,YACU,YACA,UAA+C,CAAC,GAChD,YAA+B,CAAC,GACxC;AAHQ;AACA;AACA;AAER,aAAS,IAAI,GAAG,IAAI,KAAK,YAAY,KAAK;AAExC,YAAM,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQnB,YAAM,OAAO,IAAI,KAAK,CAAC,UAAU,GAAG,EAAE,MAAM,yBAAyB,CAAC;AACtE,YAAM,SAAS,IAAI,OAAO,IAAI,gBAAgB,IAAI,GAAG,EAAE,MAAM,SAAS,CAAC;AAEvE,aAAO,YAAY,KAAK,oBAAoB,KAAK,MAAM,CAAC;AACxD,WAAK,QAAQ,KAAK,EAAE,QAAQ,MAAM,KAAK,CAAC;AAAA,IAC1C;AAAA,EACF;AAAA,EAEQ,oBAAoB,aAAqB,OAAqB;AACpE,UAAM,EAAE,OAAO,IAAI,MAAM;AACzB,YAAQ,IAAI,MAAM;AAClB,SAAK,QAAQ,WAAW,EAAE,OAAO;AACjC,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,WAAc,UAAqD;AACjE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,iBAAiB,MAAM;AAC3B,mBAAW,iBAAiB,KAAK,SAAS;AACxC,cAAI,cAAc,MAAM;AACtB,0BAAc,OAAO;AAGrB,0BAAc,OAAO,YAAY,EAAE,QAAQ,SAAS,QAAQ,OAAO,SAAS,MAAM,CAAC;AAEnF,0BAAc,OAAO,YAAY,CAAC,UAAwB;AACxD,sBAAQ,MAAM,KAAK,MAAM;AACzB,4BAAc,OAAO;AACrB,mBAAK,WAAW;AAAA,YAClB;AAEA,0BAAc,OAAO,UAAU,CAAC,UAAU;AACxC,qBAAO,KAAK;AACZ,4BAAc,OAAO;AACrB,mBAAK,WAAW;AAAA,YAClB;AAEA;AAAA,UACF;AAAA,QACF;AAGA,aAAK,UAAU,KAAK,MAAM,KAAK,WAAW,QAAQ,EAAE,KAAK,OAAO,EAAE,MAAM,MAAM,CAAC;AAAA,MACjF;AAEA,qBAAe;AAAA,IACjB,CAAC;AAAA,EACH;AAAA,EAEQ,aAAa;AACnB,QAAI,KAAK,UAAU,SAAS,GAAG;AAC7B,YAAM,OAAO,KAAK,UAAU,MAAM;AAClC,UAAI;AAAM,aAAK;AAAA,IACjB;AAAA,EACF;AACF;",
  "names": []
}
